# VM86 模式

`VM8086` 模式 [^osdev] 是“保护模式”的子模式。简而言之，`VM8086` 模式是指 CPU(在保护模式下) 运行一个模拟的 16 位实模式机器。

## 内存结构

![](../05%20内存管理/images/memory_map_vm86.drawio.svg)

## 进入 VM8086 模式

当 `EFLAGS` 寄存器中设置了 `VM` 位时，CPU 处于 `VM8086` 模式。如果要进入 虚拟86 模式，必须将该位设置为 1。修改 `EFLAGS` 寄存器的一种方法是使用 `pushf` 和 `popf` 指令，但是这些指令是针对用户空间的，不能修改管理器标志。设置 VM 标志的唯一方法是使用 `iret` 指令。该指令通常用于从中断中返回。当IRET在堆栈 `EFLAGS` 中被 VM=1 调用时(返回到的上下文是 VM8086)，中断堆栈帧将包含段 ES, DS, FS 和 GS，因此它们可以在进入之前设置。

任务门也可以用来进入 VM8086 。这允许设置段寄存器。除非操作系统使用硬件多任务处理，否则可能没有必要这样做。

![](../04%20中断和时钟/images/eflags.drawio.svg)

## VM8086 问题

VM8086 模式最常见的问题是无法从 VM8086 任务内部进入保护模式。换句话说，如果您正在运行 Windows 或内存中有 emm386，那么您就不能进行“原始”切换到保护模式(这会导致异常)。DOS 扩展程序通过使用 VCPI 或 DPMI 接口切换到 pmode 来解决这个问题(实际上，将它们的 VM8086 任务提升为“常规”用户任务)。对于操作系统程序员来说，这样的接口毫无用处，因为它们是另一个操作系统的一部分。

当人们使用 VM8086 模式时，还有一些其他的技术问题，主要是因为 VM8086 有一些指令被所谓的 VM8086 监视器程序模拟，因为CPU 处于保护模式，一些指令在安全/保护级别上很高，直接运行这些指令会给操作系统带来无休止的麻烦。

## 检测 VM8086

如果 VM8086 任务使用 `pushfd`，则 `EFLAGS.VM` 永远不会被压入堆栈。你应该检查一下 `CR0.PE=1`，然后假设它是 VM8086，如果该位被设置。

```s
detect_vm8086:
   smsw    ax
   and     eax,1    ;CR0.PE bit
   ret
```

VM8086 模式检测主要用于编写 DOS 扩展程序或其他可以从保护模式系统以纯实模式或虚拟模式启动的程序。一个普通的引导加载程序不应该担心这个，因为 BIOS 不会设置 VM8086 读取引导扇区。

## 使用

如果需要在保护模式下访问 BIOS 功能，VM8086 可能非常有用。事实上，为了设置视频模式是必要的，因为许多现代卡/芯片组缺乏对 VBE3 保护模式接口的支持，因此设置一个 VM8086 任务将执行 **设置视频模式** 调用是首选方法。

## 内核位置低于 1M

建议您将内核映射到高逻辑地址(例如 `0xC0000000`, Linux 使用这个地址)，以避免 VM8086 任务干扰它。对于大型内核来说，这一点尤其重要，因为大型内核没有留给小于 1MB 的 VM8086 代码空间，或者当更大的程序需要在 VM8086 机器中运行时。

如果所需要的只是一个 BIOS 中断包装器，那么以下应该可以工作:

1. 确保您的 16 位代码与任何 32 位代码在单独的页面上
2. 启用分页
3. 为 DPL3 设置内核页不可写(和不可读?)，并且只允许用户访问那些包含 16 位代码的页和包含 BIOS 代码或数据的页。

## 使用 VM8086 进行磁盘访问

虽然理论上可行，但这可能不是一个好主意。大多数 BIOS磁盘 访问将包括 IRQ 处理程序，DMA 传输(在您的 VM 监视器中不可控)，并且可能在 BIOS 等待中断响应时卡住 VM8086 任务，而一个好的驱动程序会让 CPU 释放给其他进程。

Windows 9x 在访问磁盘时系统冻结。通常是由于 VM8086 INT 13 的问题。

## 参考

- <https://wiki.osdev.org/Virtual_Monitor>

[^osdev]: <https://wiki.osdev.org/Virtual_8086_Mode>