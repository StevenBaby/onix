# 鼠标

## 鼠标接口

目前的个人电脑通常使用 PS2 鼠标，或类似的格式，模拟 PS2 鼠标。串行老鼠是一种更古老的技术，不再常见。

### USB 鼠标

USB 鼠标通常模拟 PS2 鼠标，除了它从 USB 总线生成 IRQ，而不是 IRQ12，一个好主意是选择复选框“启用鼠标捕获”。“鼠标切换方法”使您能够从列表热键中选择在启用或禁用鼠标捕获之间进行切换。

## Bochs

如果使用 bochs，并希望鼠标模仿 PS2 鼠标，你需要编辑键盘和鼠标设置，并将鼠标类型设置为 “ps2” (这是没有鼠标滚轮按钮的鼠标) 或“imps2” (这是有鼠标滚轮按钮的鼠标)。

## PS2 鼠标-基本操作(微软兼容)

一旦鼠标被初始化(见下文)，鼠标发送 3 或 4 字节的数据包来传递鼠标移动和鼠标按钮按下/释放事件。这些数据包在 IO 端口 0x60 上异步显示为数据。即使数据显示在端口 0x60 (键盘端口) 上，它也不会触发 IRQ1，鼠标数据已经到达的唯一方法是，如果您处理适当的 IRQ(通常是 IRQ12)，或者如果您偶尔轮询端口 0x64 的比特数0(值=1)，看看端口 0x60 上是否有数据可用。没有必要在驱动程序中处理以下所有事情，但这样做可以使事情更快地工作。

## 键盘/辅助数据位

由于键盘和鼠标数据都显示要在端口 0x60 上读取，因此有必要能够区分哪个是哪个。要判断端口 0x60 上是否有任何可用的数据，必须从端口0x64 读取一个字节。在来自端口 0x64 的字节中，位数 0(值=1) 表示可以在端口 0x60 上读取字节。如果设置了位，则额外的位 5 (值=0x20) 表示下一个字节来自鼠标；如果你看一下 RBIL，它说这个“鼠标位”是 MCA 特有的，但这不再是正确的。所有支持 PS2 鼠标的 PC 都使用这个位来表示传入字节是由辅助 PS2 输入端口生成的。

## PS2 鼠标子类型

有几种类型的鼠标，但它们可以分为两组，这取决于它们是否有滚轮。带有滚轮的鼠标可以在每个鼠标包中发送一个额外的字节，指示鼠标滚轮和额外按钮的状态。

没有滚轮的鼠标只使用 3 字节的数据包。如果正确初始化，具有滚动轮和多达 5 个按钮的鼠标(目前)可以发送 4 字节的数据包。

## 鼠标包信息

关于微软兼容的 PS2 鼠标包的更多细节，请参考下面的链接，或者搜索 Adam Chapweske 的文章。对于不兼容微软的鼠标，请参阅 Linux 文章。

## 定时/生成鼠标包

鼠标通常被初始化为以特定速率生成移动数据包。当鼠标移动时，默认速率为每秒 100 个数据包。如果按钮被按下或释放，鼠标也会生成一个数据包。如果鼠标没有移动，也没有按钮被点击，鼠标将不会自动生成任何数据包。

## 前 3 个报文字节的格式

即使鼠标发送的是 4 字节的数据包，前 3 字节的格式也总是相同的。

- 第一个字节有一串位标志。
- 第二个字节是“X”，也就是说，它测量鼠标水平移动，左为负。
- 第三个字节是“Y”，向下(指向用户)是负的。

对于缓慢移动，deltaX 和 deltaY 的典型值是 1 或 2，对于非常快速的移动，可能是 20。最大可能的值是 +255 到 -256 (它们有 9 位)。

TODO:

第一个字节的前两位(值 0x80 和 0x40)应该分别显示 Y 和 X 溢出。它们没有用。如果设置了它们，您可能应该丢弃整个数据包。

第一个字节的第 5 位(值 0x20) 表示 Y(第 3 个字节) 是一个负数，如果它被设置。这意味着您应该将 0xFFFFFF00 与 Y 的值进行 OR 运算，作为符号扩展(如果使用 32 位)。

第一个字节的第 4 位(值 0x10) 表示 X(第 2 个字节) 是一个负数，如果它被设置。这意味着您应该将 0xFFFFFF00 与 X 的值进行 OR 运算，作为符号扩展(如果使用 32 位)。

应该总是设置第一个字节的第 3 位(值 0x8)。这有助于维护和验证数据包的一致性。不幸的是，一些老的鼠标没有设置这个位。RBIL 声称这位应该是 0，但这是错误的。

如果设置了相应的位，则第一个字节的底部 3 位表示当前是否按下鼠标的中、右或左按钮。中间 = 位2 (value=4)，右边 = 位1 (value=2)，左边 = 位0 (value=1)。

## 可选的第 4 包字节格式

如果鼠标已被初始化，使其 mouseID 为 3 或 4，则它将在每个数据包中发送第 4 个字节。在所有当前的鼠标上，上面的两位应该被忽略。在一些鼠标上，位将根据滚轮的移动在 0 和 1 之间翻转。如果鼠标有第 4 和第 5 个鼠标按钮，那么它们的状态分别由第 4 位(值=0x10)和第5位(值 = 0x20)表示。注意：如果按钮不存在，那么这些位可能会根据滚轮的移动而翻转!(即。注意，这不会为不存在的按钮生成虚假的 “鼠标按钮单击”事件。)

第4个字节的底部(4位)将是以下值之一:

- 0：没有滚轮移动

- 1：垂直向上滚动一键

- 0xF：垂直向下滚动一键

- 2：水平滚动右键单击

- 0xE：水平滚动，左键点击

当只有垂直滚轮存在或已被激活时，第4个数据包字节仅包含:

字节4:

TODO:

然而，如果鼠标有额外的按钮并被正确初始化，那么它将看起来像这样:

TODO:

其中 Z0 到 Z3 是 Z 移动(滚轮)的 4 位带符号值，具有上面提到的值 (0,1,2,0xE, 0xF) 以及上面列出的含义。

### 非线性运动

当用户试图指向屏幕上的某个东西时，他们会在目标的大致方向上快速移动鼠标，然后减速以准确指向它。可以直接使用来自鼠标包的 deltaX/Y 值，但这样做将迫使用户移动鼠标很远，以便将光标从屏幕的一个区域移动到另一个区域。

一个更好的答案可能是根据鼠标移动的速度，将鼠标移动的幅度增加几倍。如果鼠标移动缓慢，比例因子可以为 1 ——以允许最高的灵敏度。当鼠标快速移动时，比例因子可以是 5 或 10，以允许光标在屏幕上快速移动较大距离。

显然，有很多方法可以实现这种扩展。如果在汇编程序中编写驱动程序，建议使用 BSR 命令生成 deltaX + deltaY 的近似对数 base2，并将其用作缩放因子。

## 双击

如果您打算实现双击，则需要高精度地记录下鼠标单击事件的时间戳。知道是否发生了双击的唯一方法是知道上次单击鼠标按钮发生的时间。如果两次单击之间的延迟小于某个阈值，则为双击。这里的问题是，您需要能够测量非常短的延迟，而点击之间可能会有非常长的延迟(可能是几天)，长到您的时间戳测量可能溢出。这件事需要小心处理。

## 超时/鼠标断开

如果鼠标运行正常，但没有移动或点击，则不会发送任何报文。如果鼠标没有插电，它也不会发送任何数据包。如果您想支持 PS2 鼠标的“热插拔”，那么您需要知道鼠标何时断开连接，因为您需要重新初始化它。如果您有一段时间没有看到来自鼠标的任何数据包，您可以查询鼠标，看看它是否还活着。一种方便的方法是为单个鼠标数据包发送一个特殊请求(鼠标命令 0xEB )。您将从鼠标获得一个 ACK(0xFA)，然后是一个鼠标数据包(可能所有内容都设置为 0)。请注意，您需要确保 0xFA 不会导致输入鼠标数据包的不对齐。另外请注意，如果鼠标数据包的内容不为 0，那么这意味着您的鼠标数据包不知何故已被禁用。

一般来说，在系统等待鼠标响应的任何地方设置超时是一个好主意，因为它可能永远不会出现。

## PS2 鼠标命令

开启 PS2 Aux 端口后，可以向鼠标发送命令。建议在 “重新编程” 鼠标时禁用自动数据包流模式。您可以通过向鼠标发送命令 0xF5 来实现这一点，或者通过设置 Compaq Status 字节的第 5 位来禁用“鼠标主时钟”(见下文)。

## 等待发送字节到端口 0x60 和 0x64

所有输出到端口 0x60 或 0x64 之前必须等待端口 0x64 的第 1 位(值=2)清除。同样，在 0x64 端口的第 0 位(value=1)设置之前，不能从端口 0x60 读取字节。详细信息请参见 PS2 键盘。

## 0xD4 字节，命令字节，数据字节

向鼠标发送命令或数据字节(到端口0x60)之前，必须先向端口 0x64 发送 0xD4 字节(在发送每个输出字节之前，在端口 0x64 上等待位 1)。注意:这个 0xD4 字节不会从键盘或鼠标生成任何 ACK。

## 等待来自鼠标的 ACK

在发送下一个字节之前，需要等待鼠标在每个命令或数据字节之后发送回 0xFA 确认字节(注意:复位命令可能不会被 ACK - 等待复位后的0xAA)。一些命令需要额外的数据字节，这两个字节将生成一个 ACK。

## 实用鼠标命令集

注：请记住，鼠标用 ACK (0xFA) 响应所有命令字节和数据字节。

注：表中给出的命令被发送到端口 0x60。如果一个命令需要额外的字节(比如采样率)，这个字节也会被发送到端口 0x60。

| 十六进制值 | 含义           | 描述                                                               |
| ---------- | -------------- | ------------------------------------------------------------------ |
| 0xFF       | 重置           | 鼠标可能发送 ACK (0xFA)加上几个字节，然后重置自己，并始终发送 0xAA |
| 0xfe       | 重发           | 此命令使鼠标重新向主机发送最近的数据包。                           |
| 0xf6       | 设置默认       | 关闭流，将数据包速率设置为每秒 100 个，分辨率设置为每 mm 4个像素。 |
| 0xf5       | 禁用数据包流   | 鼠标停止自动发送报文。                                             |
| 0xf4       | 启用数据包流   | 当鼠标移动或被点击时，鼠标开始自动发送报文。                       |
| 0xf3       | 设置采样率     | 需要额外的数据字节:每秒自动数据包(见下文的合法值)。                |
| 0xf2       | get mouseid    | 鼠标发送发送它当前的“ID”，这个ID可能随着鼠标初始化而改变。         |
| 0xeb       | 请求单个数据包 | 鼠标发送 ACK，随后是一个包含当前数据的完整鼠标包。                 |
| 0xe9       | 状态请求       | 鼠标先发送ACK，再发送 3 个状态字节。请参阅下面的状态字节格式。     |
| 0xe8       | 设置分辨率     | 需要额外的数据字节:像素/毫米分辨率(值0 ~ 3)                        |

## 其他无用的鼠标命令

| 十六进制值 | 含义            | 描述                                                                        |
| ---------- | --------------- | --------------------------------------------------------------------------- |
| 0xf0       | 设置远程模式    | 鼠标发送ACK (0xFA)，然后重置其移动计数器，进入远程模式                      |
| 0xee       | set Wrap mode   | 鼠标发送ACK (0xFA)，然后重置其移动计数器，进入Wrap模式                      |
| 0xec       | reset Wrap mode | 鼠标发送ACK，然后进入最后一个模式，在进入Wrap模式之前，它也重置其移动计数器 |
| 0xea       | set Stream mode | 鼠标发送ACK (0xFA)，重置移动计数器，进入上报模式                            |
| 0xe7       | 设置比例2:1     | 鼠标发送ACK并设置非线性比例2:1                                              |
| 0xe6       | 设置比例1:1     | 鼠标发送ACK并设置正常线性缩放比例“1:1”                                      |

TODO 

分辨率，缩放和采样率定义:

- 分辨率:鼠标移动每毫米的DeltaX或DeltaY。
- 缩放:对鼠标移动应用简单的非线性扭曲(参见上文的非线性移动)。
- 采样率:鼠标每秒可以发送的包数。

TODO:

注意:人眼看到的运动速度不会超过每秒 30 个样本，而且人的手指无法点击按钮

也没那么快。采样率低于 30 将导致鼠标移动明显不稳定，并可能错过鼠标按下事件。明显高于 30 的采样率将浪费宝贵的I/O总线带宽。您可以自己测试这些东西，但通常不建议使用10、20、100 或 200 的采样率。

## 初始化PS2鼠标

PC 机的 PS2 鼠标接口连接到 PS2 键盘控制器的辅助输入口。该输入可能在启动时被禁用，需要启用。当鼠标通过键盘控制器向 IO 端口 0x60 发送字节时，通常也希望鼠标生成 IRQ12 中断。此外，有必要告诉鼠标启用数据包的传输。您还可以选择启用其他鼠标特性，例如滚轮、更快的响应时间、更高的分辨率或其他鼠标按钮。

## PS/2 设备拔插 / 热插拔

创建 PS/2 设备规格的人没有指定 PS/2 设备可以在计算机保持打开状态的情况下拔插(“热插拔”)。很久以前，有些人实际上设计了 PS2 热插拔会轻微损坏的主板。然而，鼠标和键盘的连接线是用来绊倒的，有时尝试暂时将鼠标从一台机器移到另一台机器是非常合乎逻辑的，而不会使两台系统断电。因此，过去 15 年生产的所有计算机实际上都应该支持 PS2 设备的热插拔。当鼠标插入正在运行的系统时，它可能会发送一个 0xAA，然后是一个 0x00 字节，然后进入默认状态(见下文)。

## 设置 Compaq 状态/启用 IRQ12

在某些系统上，PS2 辅助端口在启动时被禁用。来自 AUX 端口的数据不会产生任何中断。要知道数据已经到达，您需要启用 AUX 端口来生成IRQ12。只有一种方法可以做到这一点，即获取/修改 `compaq status` 字节。您需要将命令字节 0x20(“获取 Compaq 状态字节”)发送到端口 0x64 上的 PS2 控制器。如果你看一下 RBIL，它说这个命令是 Compaq 特有的，但这不再是真的。该命令不生成 0xFA ACK 字节。返回的下一个字节应该是 Status 字节。(注意：在某些版本的 Bochs 上，由于某种原因，在发送此命令后，您将获得第二个字节，其值为0xD8) 获得状态字节后，需要设置位1(值=2，使能IRQ12)，清除位5(值=0x20，禁用鼠标时钟)。然后发送命令字节 0x60(“设置 Compaq 状态”)到端口 0x64，随后发送修改后的状态字节到端口 0x60。这可能会从键盘生成一个 0xFA ACK 字节。

## 辅助输入启用命令

发送启用辅助设备命令(0xA8) 到端口 0x64。这将从键盘生成一个 ACK 响应，您必须等待接收该响应。请注意，如果成功设置了 Compaq Status 字节，则不必使用此命令，但它也没有害处。

## 上电时的鼠标状态

当鼠标重置时，无论是通过通电还是使用重置命令 (0xFF)，它总是进入以下默认状态:

- 数据包禁用
- 模拟 3 键鼠标(按钮 4、5 和滚轮禁用)
- 3 字节包
- 4 像素/毫米分辨率
- 每秒 100 包的采样率

## MouseID 字节

在初始化过程中，鼠标通过响应初始化命令改变其 mouseID 来指示它具有各种特性(滚轮、第四个和第五个鼠标按钮)。所以你发送一组鼠标命令，然后用 Get mouseID 命令(0xF2) 请求 mouseID 字节。如果 mouseID 从先前的值更改，则鼠标已更改模式。mouseID 字节总是在Read mouseID 命令的 ACK 之后发送的下一个字节。在初始化时，mouseID 始终为 0。其他当前的法定值是 3 和 4。

## Init/Detection 命令序列

如果你想要超过 3 个按钮，你将不得不使用以下顺序。如果第一个序列被接受：鼠标数据包中的字节数变为 4，鼠标上的滚轮被激活，并且 mouseID 从 0 变为 3。

第一个魔术序列是这样的:

- 将采样率设置为 200
- 将采样率设置为 100
- 将采样率设置为 80
- 获取新的 id 以验证

在使用上述顺序激活滚轮后，可以使用以下附加魔术顺序激活鼠标第 4 和第 5 个按钮:

- 将采样率设置为 200
- 将采样率设置为 200
- 将采样率设置为 80
- 获取新的 ID 以验证

如果接受第二个序列，则返回的鼠标 ID 值从 3 更改为 4。

## 数据包有效

在将鼠标初始化为所需的 mouseID 值之后，其采样速率可能是每秒 80 个采样，分辨率可能是 4 像素/毫米，并且数据包仍然是禁用的。您可能想修改采样和分辨率，然后向鼠标发送 0xF4 命令，使鼠标自动生成移动数据包。

## 流媒体的优点和缺点

代替启用自动流数据包模式，可以一次请求一个鼠标数据包。这样做比流数据包模式有一些优势。您可能会看到，为了将每个 0xEB 命令发送到鼠标，您需要通过 I/O 总线发送或接收至少 4 个额外的字节，并且 I/O 总线非常慢。另一方面，典型的流模式可能每秒在 I/O 总线上发送数百个鼠标数据包字节，这比您需要的要多——所以如果有缺点的话，它可能很小。

流模式的最大问题之一是“对齐”——数据包从未定义为具有明显的边界。这意味着很容易忘记哪个鼠标字节应该是下一个数据包的第一个字节。如果您专门请求单个数据包(而不是使用流模式)，则完全避免了这个问题，因为每个数据包都以 ACK (0xFA) 开头，这很容易识别。

## 参考

- <https://wiki.osdev.org/Mouse>
- <https://forum.osdev.org/viewtopic.php?t=10247>
