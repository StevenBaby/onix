# IDE 硬盘 UDMA

## 目前的读写机制

### IDE 硬盘机制

1. read/write buf 用户缓冲
2. bread/bwrite buffer_t 查找内核高速缓冲
    - 如果没有则进行磁盘访问 ide_pio_read/write 比较耗时
3. buf 和 buffer_t 之间有一次拷贝内存 `memcpy`

### ISA DMA 软盘机制

1. read/write buf 用户缓冲
2. bread/bwrite buffer_t 查找内核高速缓冲
    - 如果没有则进行磁盘访问 isa_dma，比较低效
3. buf 和 buffer_t 之间有一次拷贝内存 `memcpy`
4. 由于 dma_buf 的限制，buffer_t 和 dma_buf 之间有一次内存拷贝 `memcpy`

## ISA DMA

在一台机器上有几种不同类型的 DMA，理解这一点非常重要。用于 ATA 驱动器的 DMA 称为 PCI 总线主控 DMA。它非常快。它完全不同于 ISA DMA，后者被限制为每秒 4MB。你可能读过的关于 8 位或 16位 DMA 通道 0 到 7 的任何东西，都根本不适用于磁盘 DMA。ATA 单字 DMA, ATA 多字 DMA, UDMA 和 ADMA 都是 PCI 总线主控 DMA 类型。

## UDMA

UDMA 是 Ultra Direct Memory Access 的缩写。

从操作系统的角度来看，常规(单字/多字) DMA 和 任何 UDMA 模式之间只有微小的区别。大多数实际的区别都精确地涉及数据在磁盘驱动器和磁盘控制器之间传输的 **方式** 和 **速度**。操作系统软件不能直接控制这部分进程。对于所有DMA方法(ADMA除外)，驱动程序软件以完全相同的方式发出完全相同的命令。

系统的其余部分所拥有的唯一控制就是在启动期间将磁盘驱动器和磁盘控制器初始化为相互兼容的 DMA 模式。这将有希望总是正确地由 BIOS 完成。

如果 BIOS 没有正确地完成这些工作，那么 OS 在引导后就有可能完成这些工作。但这是一个渺茫的机会，而且是一个丑陋的过程。如果你想尝试一下，请阅读英特尔 ATA 控制器芯片手册。

UDMA 对驱动程序产生影响的一个地方是 UDMA CRC Error 的概念。当驱动器和 PCI 控制器之间的数据块损坏时，就会发生这种情况。没有其他形式的 DMA 使用 CRC。如果在 DMA 传输期间发生错误，驱动程序需要检查错误是否基于 CRC，并重试传输至少一次，如果它是。

### 验证 CRC 错误

读取 PCI Configuration Space uint16_t 在偏移量6(设备状态)获得错误码。

----

## PRD 表

对于每个 ATA 总线，必须在内存中至少设置一个物理区域描述符表(Physical Region Descriptor Table, PRDT)，其中包含一定数量的物理区域描述符(Physical Region Descriptor, prd)。(PRDT必须是 `uint32_t` 对齐的，在物理内存中连续，不能跨越 64K 边界。)然后，您需要将当前 PRDT 的物理地址存储在 PCI 总线上的总线主控 ATA 磁盘控制器的总线主控寄存器中(见下文)。

### 设置 PRD 表

每个 DMA 传输的一半被编码在表中的一个 `uint64_t` PRD 条目(8 字节)中。(为什么它只是 DMA 传输的一半? 因为 PRD 不包含关于从哪个 LBA 读/写磁盘的任何信息。该信息以完全不同的方式发送到适当的磁盘——参见下文。)

低 `uint32_t` 是数据缓冲区的物理内存地址。(请记住，在 64 位系统中，这个地址必须适合 `uint32_t`!)

下一个 `uint16_t` 是传输大小的字节计数(不是扇区计数!) (每个 PRD 传输的最大 64K)。字节数为 0 表示 64K。下一个 `uint16_t` 是保留的(应该是 0)，除了 MSB。如果设置了 MSB，则表示此 PRD 是 PRDT 中的最后一个条目，并且整个传输集已经完成。数据缓冲区不能跨越 `64K` 边界，并且在物理内存中必须是连续的。它们不能是 “虚拟内存” 数据缓冲区。数据缓冲区上的字节计数必须与磁盘传输的扇区数量相匹配。否则，控制器将以各种方式出错。

---

## 总线主控寄存器

总线主控寄存器的 “地址” 存储在磁盘控制器的 PCI 配置空间的 BAR4 中。总线主寄存器通常是 16 个顺序 IO 端口的集合。它也可以是一个 16 字节的内存映射空间。

格式如下：

| 偏移      | 通道 | 功能      |
| --------- | ---- | --------- |
| 0x0       | 主   | 命令      |
| 0x2       | 主   | 状态      |
| 0x4 ~ 0x7 | 主   | PRDT 地址 |
| 0x8       | 从   | 命令      |
| 0xA       | 从   | 状态      |
| 0xC ~ 0xF | 从   | PRDT 地址 |

### 命令字节

命令字节只有 2 个操作位。其余的应该是 0。第 0 位(值=1) 为 **开始/停止位**。设置该位将控制器置于该ATA 通道的 DMA 模式，并且它从各自 PRDT 的开头开始。清除位将终止 ATA 通道的 DMA 模式。如果控制器处于传输过程中，则剩余的数据将被丢弃。此外，控制器不记得它在 PRDT 中走了多远。如果操作系统不保存这些信息，这些信息就会丢失。当传输完成时，必须清除该位。

第 3 位(值=8)是 **读/写位**。这是一个大问题。磁盘控制器不会自动检测下一次磁盘操作是读还是写。你必须提前告诉它，通过设置这个点。注意，从磁盘读取时，必须将该位设置为 1，并在写入磁盘时将其清除。您必须首先停止 DMA 传输(通过清除位0)，然后才能更改读/写位! 请注意上面清除位 0 的所有不良后果!控制器在 PRDT 中失去其位置。

本质上，这意味着每个 PRDT 必须只由读或写条目组成。您可以提前设置读/写位，然后“耗尽”整个 PRDT ——然后才可以执行相反的操作。


### 状态字节

状态字节中的位通常不太有用。但是，无论如何，您都需要在磁盘上的每个 IRQ 读取之后读取它。读取这个字节可能会执行一次必要的 DMA 数据到内存的缓存刷新。

- 第 7 位(仅为单纯形操作)已经完全过时了。但是，如果您希望您的操作系统支持 90 年代中期的硬件，这一点意味着您一次只能使用一个 ATA 总线用于 DMA。另一种只能使用 PIO。

- 如果检查一次，也许第 5 位和第 6 位(值 0x20 和 0x40)提供有用的信息，表示驱动器是不是可以使用 DMA。如果总线上的主驱动器或从驱动器有能力，它们应该由 BIOS 设置，并为 DMA 操作初始化。

- 如果第 2 位(值 = 4) 在操作系统接收到 IRQ 后没有设置，那么其他共享 IRQ 的设备生成了 IRQ，而不是磁盘。(您可能想在每个 IRQ 之后重置这个位，通过写入一个 4 到状态字节 IO 端口。)

- 位 1(值 = 2) 如果任何 DMA 内存传输在该 PRDT 中由于任何原因失败，则设置该位。

- 位 0(值 = 1) 在总线进入 DMA 模式时设置。当表中的最后一个 PRD 被用完时，它将被清除。通常，通过从磁盘接收适当数量的 irq，操作系统应该已经知道发生了这种情况。

## ATA/ATAPI Commands

PCI 磁盘控制器通过解释 PRDT，只处理 DMA 传输的内存部分。设备驱动程序必须分别告诉驱动器完成它的那一半工作。

要在 ATAPI 驱动器上使用 DMA，将 1 写入 Features IO 端口(Primary 总线上的 0x1F1)，并且在向驱动器发出 PACKET 命令时， maxbytecount 应该为 0。

对于 ATA，对于 PRDT 中的每个 PRD 条目，驱动程序必须向磁盘发出一个读/写 DMA 命令;指定 StartLBA 和扇区计数。

当驱动器完成每个命令时，它会发送一个 IRQ(也可能是在传输过程中)，让驱动器知道它已经准备好向磁盘控制器传输下一批数据。然后驱动程序应该读取总线主寄存器状态字节。

这些命令的格式与 28 位和 48 位 PIO 模式的 Read 和 Write 命令完全相同，除了发送到命令端口的值不同。

| 命令字节 | 功能                   |
| -------- | ---------------------- |
| 0xC8     | Read DMA (28 bit LBA)  |
| 0x25     | Read DMA (48 bit LBA)  |
| 0xCA     | Write DMA (28 bit LBA) |
| 0x35     | Write DMA (48 bit LBA) |

## 错误处理

在传输之后，如果总线主状态字节的 ERR 位(位1，值= 2)被设置，那么通过向该端口写入一个 2 来清除它。然后可以读取总线的 LBA IO 端口(0x1F3 到 0x1F6)，以找出哪个扇区失败了。

对于除 UDMA CRC 错误之外的任何错误，建议在总线上进行软件复位，以强制所有设备从 DMA 模式中撤出总线。

## 发送命令的标准顺序

1. 在系统内存中准备一个 PRDT。

2. 发送物理 PRDT 地址到总线主 PRDT 寄存器。

3. 通过设置总线主命令寄存器的读/写位来设置数据传输的方向。

4. 清除总线主状态寄存器中的错误和中断位。

5. 选择驱动器（硬盘）。

6. 将 LBA 和扇区计数发送到各自的端口。

7. 向 ATA 控制器发送 DMA 传输命令。

8. 在总线主命令寄存器上设置启动/停止位。

9. 当中断到达时(传输完成后)，通过重置启动/停止位来响应。

10. 读取控制器和驱动器状态，以确定传输是否成功完成。

## 参考文献

- <https://wiki.osdev.org/ATA/ATAPI_using_DMA>