# FPU 浮点运算单元

x86 FPU [^fpu] 最初是处理器的一个可选组件 x87，能够在硬件上执行浮点运算，但后来被集成到 CPU 中，多年来收集了大多数数学繁重的指令。现代 FPU 已经成为了 向量运算单元 的一个遗留术语，它恰好包含了最初的浮点运算。

## x86 FPU 遗留

最初，FPU 是放置在实际处理器之上的专用协处理器芯片。因为它是从核心逻辑异步执行计算的，所以它的结果应该在主处理器执行了其他几个指令之后才可用。由于错误也将异步可用，原来的 PC 有 FPU 的错误线连接到中断控制器。当 486 添加多处理器支持时，就不可能检测到哪个 FPU 引发了异常，之后他们集成了 FPU on-die，并添加了一个选项来发出常规异常而不是中断信号。为了提供向后兼容性，486 被赋予了一个引脚来取代原来的 FPU 错误线，它将被路由到 PIC，然后返回到 CPU 的 IRQ 线，用专用的协处理器模拟原始设置。这带来了不幸的后果，默认情况下，浮点异常不会按照手册推荐的方式进行操作。

## FPU 配置

由于 FPU 和向量单元的形式多种多样，需要一些逻辑才能使它们处于预期状态。

## 检查 FPU 支持

在 x86 处理器上，直到 386，FPU 都是外部的，并且是严格可选的。它们允许使用不同的浮点单元，包括那些不严格对应处理器生成的浮点单元。例如，386 可以同时使用 287(与 286 对应的 FPU) 和 387(当代的FPU)。486 系列微处理器分为 486DX 和 486SX，前者包含一个片上浮点单元，后者不包含浮点单元。外部 487 协处理器本质上是一个修改后的 486DX，它禁用了安装的 CPU。从奔腾开始的所有x86 CPU 都有一个集成的 FPU(不包括 NexGen 5x86)。

检测 FPU 有两种方法:

- 检查 CPUID 中的 FPU 位；
- 检查 CR0 中的 EM 位，如果它被设置，那么 FPU 不应该被使用；
- 检查 CR0 中的 ET 位，如果它被清除，那么 CPU 在引导时没有检测到 80387；
- 探测 FPU；

正确的顺序有点可疑。当前的官方手册指出，当 FPU 不存在时，尝试使用 FPU 会锁住 CPU。然而，有许多源代码包含不同复杂程度的探测代码，人们普遍认为不执行 fwait 或实际计算。类似地，EM 和 ET 位可以通过代码修改，并且可能没有正确的值。实际硬件上的不同连线也可能导致 386 没有将 FPU 检测为 80386，导致 ET 位在引导时具有错误的值。

测试 FPU 是否存在的常见方法是让它在某个地方写状态，然后检查它是否真的写了。

要区分 287 和 387 FPU，您可以尝试它是否可以看到 $+\infty$ 和 $-\infty$ 之间的差异。

## FPU 控制

如果发现存在 FPU，则应相应地设置控制寄存器。如果 FPU 不存在，也应该相应地设置寄存器。

- CR0.EM (bit 2) (**EM**ulated)

    如果设置了 EM 位，所有 FPU 和向量操作都将导致 #UD，因此它们可以在软件中模拟。清楚 EM 位才能使用 FPU；

- CR0.ET (bit 4)

    这个位在 386 上用于告诉它如何与协处理器通信，对于287 是 0，对于 387 或更高版本是 1，这个位是硬连接在 486+ 上的

- CR0.NE (bit 5)

    当设置时，启用本地异常处理，将使用 FPU 异常。当被清除时，通过中断控制器发送一个异常。486+ 应该有，但 386 没有；

- CR0.TS (bit 3)

    任务切换。FPU 状态被设计为延迟切换，以节省读写周期。如果设置，所有有意义的操作都会导致 #NM 异常，以便 OS 备份 FPU 状态。该位在硬件任务开关上自动设置，可以使用 CLTS 操作码清除。如果软件任务切换想要延迟存储 FPU 状态，可能需要手动设置这个位重新调度。

- CR0.MP (bit 1)

    除了说明 FWAIT 操作码是否免于响应 TS 位外，它几乎没有其他作用。由于 FWAIT 将强制异常序列化，它通常应该设置为 EM 位取反，因此 FWAIT 实际上会在FPU 指令是异步的时候引起 FPU 状态更新，而不是在它们被模拟的时候；

- CR4.OSFXSR (bit 9)

    启用 128 位 SSE 支持。当清除时，大多数 SSE 指令将导致无效的操作码，FXSAVE 和 FXRSTOR 将只包括原始的 FPU 状态。设置后，SSE 是允许的，XMM 和 MXCSR 寄存器是可访问的，这也意味着您的操作系统应该维护那些额外的寄存器。尝试在没有 SSE 的 CPU 上设置此位将导致异常，因此您应该首先检查 SSE(或长模式)支持。

- CR4.OSXMMEXPT (bit 10)

    启用 #XF 异常。当清除时，SSE 将一直工作，直到生成一个异常，之后所有 SSE 指令都将失败，操作码无效。设置后，将调用异常处理程序，并且可以诊断和报告问题。同样，在没有确保 SSE 支持的情况下，您不能设置此位

- CR4.OSXSAVE (bit 18)

    启用 XSAVE 扩展，它能够保存 SSE 状态以及其他下一代寄存器状态。再次，在设置之前检查 CPUID 在这种情况下长模式支持是不够的。

## 向量单元

MMX, 3DNow 和罕见的 EMMI 重用旧的 FPU 寄存器作为向量单元，将它们混叠为 64 位数据寄存器。这意味着它们可以在不修改 FPU 处理的情况下安全使用。但是 SSE 添加了一组全新的寄存器，因此默认情况下是禁用的。为了允许 SSE 指令，CR4。需要设置 OSFXSR。但是要小心，因为在没有 SSE 支持的处理器上编写它会导致异常。当 SSE 被启用时，应该使用 FXSAVE 和 FXRSTOR 存储整个 FPU 和向量寄存器文件。最好也启用其他 SSE 位 (CR4.OSXMMEXCPT)，以便 SSE 异常被路由到 #XF 处理程序，而不是在发生异常时自动禁用向量单元本身。

## 长模式

长模式要求 SSE 和 SSE2 可用，编译器可以自由地使用 SSE 寄存器而不是旧的 FPU 寄存器进行浮点运算。这意味着您的内核在使用任何浮点操作之前需要启用 SSE，而 32 位模式可能恰好不涉及 CR0/CR4 就可以工作。此外，长模式使 SSE 的寄存器增加了一倍，提供了 16 个 XMM 寄存器，而不是 32 位模式中的 8 个，这意味着需要保存更多的数据。

## FPU 状态

当配置 FPU 时，唯一要做的事情就是将其寄存器初始化为适当的状态。FNINIT 将重置 FPU 堆栈的用户可见部分。这将把精度设置为 64 位，并将舍入设置为最接近的值，这应该对大多数操作都是正确的。它还将屏蔽所有导致中断的异常。您可以通过发出 FLDCW 来更改控件。要诊断损坏的代码，通常需要为无效的操作数和堆栈溢出(比特 0)启用异常。比特 2 还允许捕获除零。

为 FPU 寄存器使用 MMX 别名将导致这些寄存器在浮点使用时失效。EMMS 指令将寄存器重置为非向量使用。x86 调用约定假定堆栈可用于浮点或向量使用，因此在调用或返回常规编译器生成的代码之前需要调用 EMMS。MMX 指令和 EMMS 都保留了您用 FLDCW 设置的控制字，因此您不需要随后手动调整它。

SSE 主要独立于 FPU 寄存器运行。它有一个单独的 MXCSR 寄存器，用于处理控制和异常，应该单独编写。

可以使用 `fnsave` [^fsave] 和 `frstor` [^frstor] 指令来保存和恢复 FPU 状态。

## FPU 编程

x87 FPU 包含 8 个浮点寄存器。每个浮点寄存器保存一个 80位 的扩展双精度值(1 位符号、15 位指数和 64 位分数值)，并且每个寄存器在标记寄存器中有一个匹配的 2 位 **标记** 值，作为标记寄存器。标记寄存器包含关于每个寄存器是否为空的信息，它的值是否准确，以及它的值是否为特殊值，如 无穷大 或 Nan (Not a Number 不是一个数字)。

8 个浮点寄存器以 堆栈 的方式组织，大多数 FPU 指令在堆栈的当前 顶部 (默认为寄存器 0) 上操作。当前的栈顶寄存器索引存储在 FPU 状态寄存器中，并在执行 PUSH (FLD) 或 POP (FST) 指令时由 FPU 自动更新。当所有 8 个堆栈寄存器都满了(即所有 8 个标记寄存器都没有标记为 **空**)，并且执行 PUSH 指令时，将发生 FPU 堆栈溢出异常。如果开启了 STACK-OVERFLOW 异常，主 CPU 也会收到一个异常。

因为 x87 FPU 是一个独立的处理器(并且有自己的时钟)，它可以在 CPU 执行自己指令的同时并行执行 FPU 指令。使用 x87 FPU 的应用程序必须首先执行一个或多个 FPU 命令，然后在稍后的某个时刻，它必须指示主 CPU 等待 FPU 完成处理 `FWAIT`，以确保 FPU 已经完成了这些指令的执行。大多数 x87 FPU 指令都有一个 **等待版本** 和一个 **不等待版本**，这样程序员就可以指定在应用程序中的哪个点需要同步两个处理器。在 `FWAIT` CPU 指令被执行之后 (或者一个 `wait` 指令被执行)，任何由 FPU 执行的计算 (或者任何已经被 FPU 检测到的异常) 都可以由应用程序在那一点上处理。

从 ST(0) 到 ST(7) 向 8 个 FPU 寄存器发送数据，并从 ST(7) 中提取数据，必须使用系统内存来执行。直接从 CPU 寄存器复制值到 FPU 寄存器是不可能的。FPU 从系统内存中拷贝数据的格式包括 16-Bit Integer、32-Bit Integer、32-Bit Float(单)、64-Bit Float(双)、80-bit Float(扩展双)。FPU 还支持读写 80 位 BCD  (Binary Coded Decimal) 格式，该格式包含一个符号位，7 位保留位和 18 个 4 位十六进制字符。

当从系统内存中读取值时，扩展双精度格式直接复制到 FPU 寄存器中，而其他格式则转换为 80 位扩展双精度格式，然后存储到 FPU 寄存器中。当将值写入系统内存时，在存储扩展双格式时直接复制 80 位值，并将其转换为适用于其他格式的适当结构。此转换包括根据 FPU 控制寄存器中的当前舍入设置对值进行舍入。

## 参考

[^fpu]: <https://wiki.osdev.org/Fpu>
[^fsave]: <https://www.felixcloutier.com/x86/fsave:fnsave>
[^frstor]: <https://www.felixcloutier.com/x86/frstor>
