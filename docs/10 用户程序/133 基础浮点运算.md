# 基础浮点运算

在现代 `x86_64` 的系统上，`x87` 的部分指令存在一些问题，比如精度不够、运行速度慢等因素，已经渐渐被弃用。现在大部分 `ABI` 都是 `SSE` 指令实现，然后以 `x87` 的格式返回[^forward]。

为什么 `x87` 的部分指令精度不够？

> 比如实现 `sin` 函数，硬浮点受限于 `FPU` 的寄存器位数，而软浮点可用泰勒展开，扩展更方便，理论上泰勒展开是无限的。

`glibc` 利用泰勒展开实现三角函数 [^glibc]

为了学习 `FPU` 指令，避免 `gcc` 生成 `SSE` 指令，可以限定处理器类型为 奔腾处理器 [^options]：

```makefile
CFLAGS+= -march=pentium # pentium 处理器
```

## 基础浮点函数

设 $x=ST0, y=ST1$

| 指令    | 描述                               |
| ------- | ----------------------------       |
| F2XM1   | $x = 2^x - 1$                      |
| FABS    | $x = \|x\|$ [^fabs]                 |
| FCHS    | $x = -x$                           |
| FCOS    | $x = \cos(x)$                      |
| FPATAN  | $y = \arctan({y \over x})$         |
| FPREM   | $x = fmodf(x, y)$ [^fmodf]         |
| FPREM1  | $x = reminderf(x, y)$ [^remainder] |
| FPTAN   | $y = \tan(x), x = 1$               |
| FRNDINT | $x = \lfloor x \rfloor$            |
| FSCALE  | $x = x \cdot 2^{[y]}$              |
| FSIN    | $x = \sin(x)$                      |
| FSINCOS | $x = \cos(x), y =\sin(x)$          |
| FSQRT   | $x = \sqrt{x}$                     |
| FYL2X   | $y = y \cdot \log_2(x)$            |
| FYL2XP1 | $y = y \cdot \log_2(x + 1)$        |

## FPU Status Word [^fsw]

用于指示 `FPU` 当前的状态和条件码

| 15 | 14 | 13 ~ 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| -  | -  | -       | -  | -  | -  | -  | -  | -  | -  | -  | -  | -  | -  |
| B  | C3 | TOP     | C2 | C1 | C0 | ES | SF | PE | UE | OE | ZE | DE | IE |

参考手册 `8.1.3 x87 FPU Status Register` 节 [^manual]

## FXAM — Examine Floating-Point [^examine]

| Class                | C3 | C2 | C0 |
|----------------------|----|----|----|
| Unsupported          | 0  | 0  | 0  |
| NaN                  | 0  | 0  | 1  |
| Normal finite number | 0  | 1  | 0  |
| Infinity             | 0  | 1  | 1  |
| Zero                 | 1  | 0  | 0  |
| Empty                | 1  | 0  | 1  |
| Denormal number      | 1  | 1  | 0  |

`FPU` 的比较指令会改变状态寄存器的 `C3` 和 `C0` 位，比较后跟据`ST(0)`和源操作数的大小，设置 `C3` 和 `C0` 标志位 [^fpu_cnblogs]：

| 比较结果       | C3 | C0 |
|----------------|----|----|
| ST(0)>源操作数 | 0  | 0  |
| ST(0)<源操作数 | 0  | 1  |
| ST(0)=源操作数 | 1  | 0  |
| ST(0)不可比较  | 1  | 1  | 

 另外，`C1` 是符号标记位，参考手册 `8.1.3.2 Condition Code Flags` 节 [^manual]
 > The FXAM instruction sets C1 to the sign of the value being examined

 ## FPU Control Word [^fcw]

用于控制 `FPU` 执行浮点运算时的参数设置，参考手册 `8.1.5 x87 FPU Control Word` 节 [^manual]

## IEEE754

`IEEE`二进制浮点数算术标准 [^ieee754]

## 内联汇编语法格式

对 `FPU` 指令封装用了大量内联汇编，可以参考这里 [^asm_fmt]，或者直接看 `GCC` 官网 [^gcc_asm_fmt]

## 参考

[^forward]: <https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170#floating-point-support-for-older-code>
[^glibc]: <https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/ieee754/dbl-64/s_sin.c;hb=HEAD#l281>
[^options]: <https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html>
[^manual]: <https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html>
[^fabs]: <https://en.cppreference.com/w/c/numeric/math/fabs>
[^fmodf]: <https://en.cppreference.com/w/c/numeric/math/fmod>
[^remainder]: <https://en.cppreference.com/w/c/numeric/math/remainder>
[^fcw]: <http://nacad.ufrj.br/online/intel/Documentation/en_US/compiler_f/main_for/fpops/fortran/fpops_contw_f.htm>
[^fsw]: <http://www.website.masmforum.com/tutorials/fptute/fpuchap1.htm>
[^examine]: <https://www.felixcloutier.com/x86/fxam>
[^fpu_cnblogs]: <https://www.cnblogs.com/wzf365/p/3388097.html>
[^ieee754]: <https://en.wikipedia.org/wiki/IEEE_754>
[^asm_fmt]: <https://www.cnblogs.com/elnino/p/4313340.html>
[^gcc_asm_fmt]: <https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C>
